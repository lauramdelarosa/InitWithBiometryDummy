package com.example.kieun.biometricprompt

import android.hardware.biometrics.BiometricManager
import android.os.Build
import android.os.Bundle
import android.os.Handler
import android.os.Looper
import android.security.keystore.KeyGenParameterSpec
import android.security.keystore.KeyProperties
import android.util.Base64
import android.util.Log
import android.widget.Toast
import androidx.appcompat.app.AppCompatActivity
import androidx.biometric.BiometricPrompt
import androidx.core.hardware.fingerprint.FingerprintManagerCompat
import java.security.*
import java.security.spec.ECGenParameterSpec
import java.util.*
import java.util.concurrent.Executor

class MainActivitys : AppCompatActivity() {

    private var mToBeSignedMessage: String? = null

    private// Callback for biometric authentication result
    // Normally, ToBeSignedMessage and Signature are sent to the server and then verified
    // Error
    val authenticationCallback: BiometricPrompt.AuthenticationCallback
        get() = object : BiometricPrompt.AuthenticationCallback() {
          override fun onAuthenticationSucceeded(result: BiometricPrompt.AuthenticationResult) {
                Log.i(TAG, "onAuthenticationSucceeded")
                super.onAuthenticationSucceeded(result)
                if (result.cryptoObject != null && result.cryptoObject?.signature != null) {
                    try {
                        val signature = result.cryptoObject?.signature
                        signature?.update(mToBeSignedMessage?.toByteArray())
                        val signatureString = Base64.encodeToString(signature?.sign(), Base64.URL_SAFE)
                        Log.i(TAG, "Message: $mToBeSignedMessage")
                        Log.i(TAG, "Signature (Base64 EncodeD): $signatureString")
                        Toast.makeText(applicationContext, "$mToBeSignedMessage:$signatureString", Toast.LENGTH_SHORT).show()
                    } catch (e: SignatureException) {
                        throw RuntimeException()
                    }

                } else {
                    Toast.makeText(applicationContext, "Something wrong", Toast.LENGTH_SHORT).show()
                }
            }
        }

    private val mainThreadExecutor: Executor get() = MainThreadExecutor()

    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        setContentView(R.layout.activity_main)

        if (canAuthenticateWithBiometrics()) {  // Check whether this device can authenticate with biometrics
            Log.i(TAG, "Try registration")
            // Generate keypair and init signature
            val signature: Signature?
            try {
                val keyPair = generateKeyPair(KEY_NAME, true)
                // Send public key part of key pair to the server, this public key will be used for authentication
                mToBeSignedMessage = Base64.encodeToString(keyPair.public.encoded, Base64.URL_SAFE) +
                        ":" +
                        KEY_NAME +
                        ":" +
                        // Generated by the server to protect against replay attack
                        "12345"

                signature = initSignature(KEY_NAME)
            } catch (e: Exception) {
                throw RuntimeException(e)
            }

            // Create biometricPrompt
            showBiometricPrompt(signature)
        } else {
            // Cannot use biometric prompt
            Toast.makeText(this, "Cannot use biometric", Toast.LENGTH_SHORT).show()
        }
    }


    private fun showBiometricPrompt(signature: Signature?) {
        val authenticationCallback = authenticationCallback
        val mBiometricPrompt = BiometricPrompt(this, mainThreadExecutor, authenticationCallback)

        // Set prompt info
        val promptInfo = BiometricPrompt.PromptInfo.Builder()
            .setDescription("Description")
            .setTitle("Title")
            .setSubtitle("Subtitle")
            .setNegativeButtonText("Cancel")
            .build()

        // Show biometric prompt
        if (signature != null) {
            Log.i(TAG, "Show biometric prompt")
            mBiometricPrompt.authenticate(promptInfo, BiometricPrompt.CryptoObject(signature))
        }
    }

    @Throws(Exception::class)
    private fun generateKeyPair(keyName: String, invalidatedByBiometricEnrollment: Boolean): KeyPair {
        val keyPairGenerator = KeyPairGenerator.getInstance(KeyProperties.KEY_ALGORITHM_EC, "AndroidKeyStore")

        val builder = KeyGenParameterSpec.Builder(
            keyName,
            KeyProperties.PURPOSE_SIGN
        )
            .setAlgorithmParameterSpec(ECGenParameterSpec("secp256r1"))
            .setDigests(
                KeyProperties.DIGEST_SHA256,
                KeyProperties.DIGEST_SHA384,
                KeyProperties.DIGEST_SHA512
            )
            // Require the user to authenticate with a biometric to authorize every use of the key
            .setUserAuthenticationRequired(true)

        // Generated keys will be invalidated if the biometric templates are added more to user device
        if (Build.VERSION.SDK_INT >= 24) {
            builder.setInvalidatedByBiometricEnrollment(invalidatedByBiometricEnrollment)
        }

        keyPairGenerator.initialize(builder.build())

        return keyPairGenerator.generateKeyPair()
    }

    @Throws(Exception::class)
    private fun getKeyPair(keyName: String): KeyPair? {
        val keyStore = KeyStore.getInstance("AndroidKeyStore")
        keyStore.load(null)
        if (keyStore.containsAlias(keyName)) {
            // Get public key
            val publicKey = keyStore.getCertificate(keyName).publicKey
            // Get private key
            val privateKey = keyStore.getKey(keyName, null) as PrivateKey
            // Return a key pair
            return KeyPair(publicKey, privateKey)
        }
        return null
    }

    @Throws(Exception::class)
    private fun initSignature(keyName: String): Signature? {
        val keyPair = getKeyPair(keyName)

        if (keyPair != null) {
            val signature = Signature.getInstance("SHA256withECDSA")
            signature.initSign(keyPair.private)
            return signature
        }
        return null
    }

    private class MainThreadExecutor : Executor {
        private val handler = Handler(Looper.getMainLooper())

        override fun execute(r: Runnable) {
            handler.post(r)
        }
    }

    /**
     * Indicate whether this device can authenticate the user with biometrics
     * @return true if there are any available biometric sensors and biometrics are enrolled on the device, if not, return false
     */
    private fun canAuthenticateWithBiometrics(): Boolean {
        // Check whether the fingerprint can be used for authentication (Android M to P)
        return if (Build.VERSION.SDK_INT < 29) {
            val fingerprintManagerCompat = FingerprintManagerCompat.from(this)
            fingerprintManagerCompat.hasEnrolledFingerprints() && fingerprintManagerCompat.isHardwareDetected
        } else {    // Check biometric manager (from Android Q)
            val biometricManager = this.getSystemService<BiometricManager>(BiometricManager::class.java)
            if (biometricManager != null) {
                biometricManager.canAuthenticate() == BiometricManager.BIOMETRIC_SUCCESS
            } else false
        }
    }

    companion object {
        private val TAG = MainActivitys::class.java.name

        // Unique identifier of a key pair
        private val KEY_NAME = UUID.randomUUID().toString()
    }
}
